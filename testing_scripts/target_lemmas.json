{
    "rank_right_height" : "has_leftist_property h = true -> rank h = right_height h",
    "leftist_mergea" : "has_leftist_property l && has_leftist_property r = true -> has_leftist_property (mergea v l r) = true",
    "leftist_merge" : "has_leftist_property h1 && has_leftist_property h2 = true -> has_leftist_property (merge h1 h2) = true",
    "leftist_hinsert" : "has_leftist_property x = true -> has_leftist_property (hinsert x n) = true",
    "le_O_n" : "0 <= S (n)",
    "app_nil" : "app x Nil = x",
    "app_assoc" : "app x (app y z) = app (app x y) z",
    "len_append" : "len (append x y) = len x + len y",
    "append_assoc" : "append (append x y) z = append x (append y z)",
    "rev_append_cons_aux" : "rev (append (rev l1) (Cons x l2)) = append (rev l2) (Cons x l1)",
    "insert_n_S" : "(tsize (tinsert t n)) = S (tsize t)",
    "plus_n_Sm" : "S (n + m) = S (n) + m ... or something like that",
    "rev_append" : "rev (append x y) = append (rev y) (rev x)",
    "append_nil" : "append x Nil = x",
    "rev2_append_aux" : "append (rev2 x Nil) (append a b) = append (rev2 x a) b",
    "append_single" : "append (Cons n Nil) a = Cons n a",
    "list_rev2_len_lem" : "len (rev l1 l2) = (len l1) + (len l2)",
    "plus_n_0" : "n + 0 = n",
    "rev2_append" : "rev2 x a = append (rev2 x Nil) a",
    "len_rev" : "len (rev l) = len l",
    "len_app" : "len (app l1 l2) = (len l1) + (len l2)",
    "len_butlast" : "S (len (butlast (Cons n l))) = len (Cons n l)",

    "Permutation_length" : "Permutation x y -> length x = length y",
    "Forall_forall" : "Forall P l <-> (forall x, In x l -> P x)",
    "Permutation_in" : "Permutation l m -> In x l -> In x m",
    "Permutation_app_comm" : "Permutation (m ++ n) (n ++ m)",
    "Permutation_trans" : "Permutation l m -> Permutation m n-> Permutation l n",
    "app_nil_r" : "[ ] ++ l = l",
    "Permutation_cons_app" : "Permutation l (l1 ++ l2) -> Permutation (a :: l) (l1 ++ a :: l2)",
    "Permutation_app" : "Permutation l l' -> Permutation m m' -> Permutation (l++m) (l'++m')",
    "split_len" : "split l = (l1,l2) -> length l1 <= length l /\\ length l2 <= length l",

    "select_perm" : "select x l = (y, r) -> Permutation (x :: l) (y :: r)",
    "select_rest_length" : "select x l = (y, r) -> length l = length r",
    "selsort_perm" : "length l = n -> Permutation l (selsort l n)",
    "selection_sort_perm" : "Permutation l (selection_sort l)",
    "select_fst_leq" : "select x al = (y, bl) -> y <= x",
    "le_all__le_one" : "y <=* lst -> In n lst -> y <= n",
    "select_smallest" : "select x al = (y, bl) -> y <=* bl",
    "select_in" : "select x al = (y, bl) -> In y (x :: al)",
    "cons_of_small_maintains_sort" : "n = length bl -> y <=* bl -> sorted (selsort bl n) -> sorted (y :: selsort bl n)",
    "selsort_sorted" : "length al = n -> sorted (selsort al n)",
    "selection_sort_sorted" : "sorted (selection_sort al)",

    "sorted_merge1" : "x <= x1 -> x <= x2 -> sorted (merge (x1::l1) (x2::l2)) -> sorted (x :: merge (x1::l1) (x2::l2))",
    "sorted_merge" : "sorted l1 -> sorted l2 -> sorted (merge l1 l2)",
    "split_perm" : "split l = (l1,l2) -> Permutation l (l1 ++ l2)",
    "merge_perm" : "Permutation (l1 ++ l2) (merge l1 l2)",
    "mergesort_sorts" : "sorted (mergesort l)",
    "mergesort_perm" : "Permutation l (mergesort l)",
    "merge_nil_l" : "merge [] l = l",

    "bag_perm" : "bag_eqv al bl -> Permutation al bl",
    "perm_bag" : "Permutation al bl -> bag_eqv al bl",
    "app_comm_cons" : "a :: (x ++ y) = (a :: x) ++ y",
    "bag_cons_inv" : "S n = count x l -> exists l1 l2, l = l1 ++ x :: l2 /\\ count x (l1 ++ l2) = n",
    "bag_eqv_uncons" : "bag_eqv (b :: l1) (b :: l2) -> bag_eqv l1 l2",
    "Permutation_middle" : "Permutation (a :: l1 ++ l2) (l1 ++ a :: l2)",
    "count_insert_other" : "y <> x -> count y (l1 ++ x :: l2) = count y (l1 ++ l2)",
    "bag_eqv_cons" : "bag_eqv b1 b2 -> bag_eqv (x::b1) (x::b2)",
    "bag_eqv_trans" : "bag_eqv b1 b2 -> bag_eqv b2 b3 -> bag_eqv b1 b3",
    "insert_bag" : "bag_eqv (x::l) (insert x l)",

    "priqueue_perm" : "priqueue_elems p elems1 -> priqueue_elems p elems2 -> Permutation elems1 elems2",
    "tree_perm" : "tree_elems t e1 -> tree_elems t e2 -> Permutation e1 e2",
    "priqq_can_relate" : "priqq n p -> exists al, priqueue_elems p al",
    "smash_valid" : "pow2heap n t -> pow2heap n u -> pow2heap (S n) (smash t u)",
    "unzip_preq" : "pow2heapp n k t -> priqq n (f nil) -> priq (unzip t f)",
    "delete_max_aux_priq" : "priqq n p -> delete_max_aux m p = (q,q') -> priqq n q /\\ priq q'",
    "join_valid" : "priqq n p -> priqq n q -> (c=Leaf \\/ pow2heap n c) -> priqq n (join p q c)",
    "carry_valid" : "priqq n q -> forall t, (t=Leaf \\/ pow2heap n t) -> priqq n (carry q t)",
    "Permutation_app_tail" : "Permutation l l' -> Permutation (l++tl) (l'++tl)",
    "Permutation_cons_append" : "Permutation (x :: l) (l ++ x :: nil)",
    "tree_can_relate" : "exists al, tree_elems t al",
    "Permutation_nil" : "Permutation [] l -> l = []",
    "smash_valid_helper1" : "(k >? k2) = true -> k >= k2",
    "smash_valid_helper2" : "(k >? k2) = false -> k2 >= k",
    "Permutation_inv_cons" : "Permutation l l' -> Permutation (a :: l) (a :: l')",

    "maybe_swap_perm" : "maybe_swap (maybe_swap al) = maybe_swap al",
    "Permutation_app_head" : "Permutation tl tl' -> Permutation (l++tl) (l++tl')",
    "Permutation_cons_inv" : "Permutation (a::l) (a::l') -> Permutation l l'",

    "forall_permutation" : "Permutation l l' -> Forall P l -> Forall P l'",
    "select_biggest" : "select i al = (j,bl) -> Forall (fun x => j >= x) bl",
    "select_biggest_aux" : "Forall (fun x => j >= x) bl -> select i al = (j,bl) -> j >= i",

    "in_or_app" : "In a l \\/ In a m -> In a (l ++ m)",
    "elements_preserves_forall" : "ForallT P t -> Forall (uncurry P) (elements t)",
    "Forall_in" : "Forall P l -> In a l -> P a",
    "in_app_or" : "In a (l ++ m) -> In a l \\/ In a m",
    "forall_fst" : "Forall (uncurry (fun (n : nat) (_ : nat) => P n)) lst -> Forall P (list_keys lst)",
    "map_app" : "map f (l++l') = (map f l) ++ (map f l')",
    "map_cons" : "map f (x::l) = (f x) :: (map f l)",
    "NoDup_append" : "NoDup l1 -> NoDup l2 -> disjoint l1 l2 -> NoDup (l1 ++ l2)",
    "Forall_app" : "Forall P l1 -> Forall P l2 -> Forall P (l1 ++ l2)",
    "elements_correct" : "BST t -> In (k, v) (elements t) -> bound k t = true /\\ lookup d k t = v",
    "fast_elements_tr_helper" : "fast_elements_tr t lst = elements t ++ lst",
    "fast_elementst_eq_elements" : "fast_elements t = elements t",
    "ForallT_insert" : "ForallT P t -> P k v -> ForallT P (insert k v t)",
    "fast_elements_eq_elements" : "fast_elements t = elements t",
    "kvs_insert_split" : "Forall (fun '(k',_) => k' < k0) e1 -> Forall (fun '(k',_) => k' > k0) e2 -> kvs_insert k v (e1 ++ (k0,v0):: e2) = if Nat.ltb k k0 then (kvs_insert k v e1) ++ (k0,v0)::e2 else if Nat.ltb k0 k then e1 ++ (k0,v0)::(kvs_insert k v e2 else e1 ++ (k,v)::e2",
    "sorted_app" : "sorted l1 -> sorted l2 -> Forall (fun n => n < x) l1 -> Forall (fun n => n > x) l2 -> sorted (l1 ++ x :: l2)",

    "insert_swap" : "x < y -> insert y (x::l) = x :: insert y l",
    "sortedd_cons" : "x <= y -> (sortedd (y::l)) -> sortedd (x::y::l)",
    "sort_perm" : "Permutation l (sort l)",
    "sort_sorted" : "sorted (sort l)",
    "insert_sorted" : "sorted l -> sorted (insert a l)",
    "insert_sortedd" : "sortedd l -> sortedd (insert a l)",
    "nth_succ" : "nth (S n) (x::l) 0 = nth n l 0",
    "insert_perm" : "Permutation (x::l) (insert x l)",

    "plus_assoc" : "plus (plus x y) z = plus x (plus y z)",
    "plus_commut" : "plus x y = plus y x",
    "append_rev_cons" : "rev (append l1 (cons x l2)) = append (rev l2) (cons x (rev l1))",
    "rev_rev" : "rev (rev l) = l",
    "rev_rev_cons" : "cons n (rev l) = rev (append l (cons n nil))",
    "plus_succ_swap" : "plus (succ m) n = plus m (succ n)",
    "even_odd_plus" : "even (plus m n) = negb (even (plus m (succ n)))",
    "plus_succ" : "plus x (succ y) = succ (plus x y)",
    "even_odd_append_len" : "negb (even (len (append l1 l2))) = even (len (append l1 (cons n l2)))",
    "plus_comm" : "plus x y = plus y x.",
    "qreva_append" : "qreva (append x y) nil = append (qreva y nil) (qreva x nil)",
    "qrevflat_append" : "append (revflat x) y = qrevaflat x y",
    "rev_involutive" : "eq (rev (rev x)) x",
    "rev_qreva_nil" : "eq (rev x) (qreva x nil)",
    "len_append_nil" : "len l = len (append l nil)",
    "len_cons_succ" : "succ (len (append l1 l2)) = len (append l1 (cons n l2))",
    "qreva_nil" : "qreva x y = append (qreva x nil) y",
    "rotate_len_append" : "rotate (len x) (append x y) = append y x",
    "mult_assoc" : "mult (mult x y) z = mult x (mult y z)",
    "mult_commut" : "mult x y = mult y x",
    "qfac_mult" : "qfac x y = mult (qfac x (succ zero)) y",
    "plus_qmult" : "plus (qmult x y z) a = qmult x y (plus z a)",
    "mult_qexp" : "mult (qexp x y z) a = qexp x y (mult z a)",
    "Nat_beq_refl" : "Nat_beq n n = true",
    "append_cons" : "append x (cons n y) = append (append x (cons n nil)) y",
    "subset_append" : "lst_subset x (append y x)",
    "subset_refl" : "lst_subset x x",
    "eqb_refl" : "eqb n n = true",
    "insort_len" : "len (insort n x) = succ (len x)",
    "drop_succ" : "drop (succ n1) (drop n2 l) = drop n1 (drop (succ n2) l)",
    "Nat_beq_eq" : "Nat_beq x y = true -> x = y",
    "less_not_refl" : "less n n = false",
    "qreva_rev" : "qreva x y = append (rev x) y",
    "drop_cons" : "drop (succ x) (cons n l) = drop x l",
    "drop_cons_assoc" : "drop x1 (drop x2 (cons x3 l)) = drop x2 (drop x1 (cons x3 l))",
    "drop_nil" : "drop x nil = nil",
    "drop_assoc" : "eq (drop x (drop y z)) (drop y (drop x z))",
    "distrib" : "mult (plus x y) z = plus (mult x z) (mult y z)",
    "mult_succ" : "plus (mult x y) x = mult x (succ y)",
    "mult_zero" : "mult x zero = zero",
    "plus_zero" : "plus x zero = x",

    "lookup_make_black" : "lookup default k (make_black t) = lookup default k t",
    "balance_lookup" : "BST l -> BST r -> ForallT (fun k' _ => k' < k) l -> ForallT (fun k' _ => k' > k) r -> lookup default k' (balance c l k v r) = if k' <? k then lookup default k' l else if k <? k' then lookup default k' r else v",
    "ForallT_imp" : "ForallT P t -> (forall k v, P k v -> Q k v) -> ForallT Q t",
    "balanceP" : "ForallT P l -> ForallT P r -> P k v -> ForallT P (balance c l k v r)",
    "lookup_ins_eq" : "BST t -> lookup default k (ins k v t) = v",
    "RB_blacken_parent" : "RB t Red n -> RB t Black n",
    "ins_BST" : "BST t -> BST (ins k v t)",
    "insP" : "ForallT P t -> P k v -> ForallT P (ins k v t)",
    "make_black_BST" : "BST t -> BST (make_black t)",
    "balance_BST" : "ForallT (fun k' _ => k' < k) l -> ForallT (fun k' _ => k' > k) r -> BST l -> BST r -> BST (balance c l k v r)",
    "RB_blacken_root" : "RB t Black n -> exists (n' : nat), RB (make_black t) Red n'",
    "elements_trP" : "ForallT P t -> Forall (uncurry P) l -> Forall (uncurry P) (elements_tr t l)",
    "Forall_In" : "Forall P l -> In a l -> P a",
    "ins_RB" : "RB t Red n -> RB (ins k v t) Black n",
    "ins_red" : "RB t Red n -> RB (ins k v t) Black n",

    "positive2nat_pos" : "positive2nat p > 0",
    "succ_correct" : "positive2nat (succ p) = S (positive2nat p)",
    "look_leaf" : "look a j Leaf = a",

    "goal38_1" : "mem x y -> mem x (append y z)",
    "goal50_3" : "x <> y -> count x (insort y l) = count x l",
    "goal41_3" : "lst_subset x y -> lst_subset x (append z y)",
    "goal49_2" : "mem x (cons n l) = true -> x = n \/ mem x l = true",
    "goal62_2" : "less x y = false -> leq y x = true",
    "goal38_2" : "mem x z -> mem x (append y z)",
    "goal42" : "lst_mem x y = true -> lst_mem x (lst_union z y) = true",
    "goal49_1" : "mem x (cons n l) = true -> x = n \/ mem x l = true",
    "goal62_1" : "less x y = false -> leq y x = true",
    "goal47_1" : "n <> m -> eqb n m = false",
    "goal50_1" : "x <> y -> count x (cons y l) = count x l",
    "goal69_1" : "Nat_beq x y = true -> x = y",
    "goal41_1" : "lst_mem n x = true -> lst_mem n (append y x) = true",
    "goal44" : "Nat_beq x y = true -> x = y",
    "goal47_2" : "n <> m -> eqb n m = false",
    "goal50_2" : "Bool.Is_true (eqb x y) -> x = y",
    "goal14" : "sorted l = true -> sorted (insort n l) = true",
    "goal41_2" : "lst_subset x y -> lst_subset x (append z y)",
    "goal69_2" : "Nat_beq x y = true -> x = y",
    "goal49_3" : "mem x (insort n l) = true -> x = n \/ mem x l = true"
}